路由：Vue Router
主要包含两部分：路由跳转及导航守卫

动态路由匹配：
一个“路径参数”使用冒号 : 标记。
当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。
{ path: '/user/:id', component: User }。像 /user/foo 和 /user/bar 都将映射到相同的路由。
使用：
const userId = '123'
router.push({ name: 'user', params: { userId }}) // -> /user/123
router.push({ path: `/user/${userId}` }) // -> /user/123
说明：
当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。
因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。
不过，这也意味着组件的生命周期钩子不会再被调用。

router.push(location, onComplete?, onAbort?)：
// 字符串
router.push('home')
// 对象
router.push({ path: 'home' })
// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})
// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})

router.replace(location, onComplete?, onAbort?)：
跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，
而是跟它的方法名一样 —— 替换掉当前的 history 记录。

router.go(n)：
这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步
// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)
// 后退一步记录，等同于 history.back()
router.go(-1)
// 如果 history 记录不够用，那就默默地失败呗
router.go(-100)
router.go(100)

重定向：
当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b
从 /a 重定向到 /b：
const router = new VueRouter({
  routes: [
    { path: '/a', redirect: '/b' }
	{ path: '/a', redirect: { name: 'foo' }}
	{ path: '/a', redirect: to => {
      // 方法接收 目标路由 作为参数
      // return 重定向的 字符串路径/路径对象
    }}
  ]
})

别名：
{ path: '/a', component: A, alias: '/b' }
/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，
但是路由匹配则为 /a，就像用户访问 /a 一样。

导航守卫：
vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。
有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。

全局前置守卫：router.beforeEach
router.beforeEach((to, from, next) => {
  // ...
})
to: Route: 即将要进入的目标 路由对象
from: Route: 当前导航正要离开的路由
next: Function: 执行效果依赖 next 方法的调用参数。

全局解析守卫：router.beforeResolve
在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

全局后置钩子：router.afterEach
钩子不会接受 next 函数也不会改变导航本身。
router.afterEach((to, from) => {
  // ...
})

路由独享的守卫：router.beforeEnter
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})

组件内的守卫：beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave
可以在路由组件内直接定义这些路由导航守卫。
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}













