每个 Vue 应用都需要通过实例化 Vue 来实现。

获取vue实例中的属性或是方法直接使用this.来获取就可以了。

{{ }} 用于输出对象属性和函数返回值。

分离又建立联系,
JavaScript代码与HTML文档分离，但又相互作用，即实现用更少的代码做更多的事。

Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地/将 DOM 绑定至底层 Vue 实例的数据。

Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的/将数据渲染进 DOM 的系统。

结合响应系统，在应用状态改变时， Vue 能够智能地计算出/重新渲染组件的最小代价并应用到 DOM 操作上。

var vm = new Vue({
	el ： "#app",
	data ： {
		site： "菜鸟教程",
		url： "www.runoob.com",
		alexa： "10000"
	},
	methods ： {
		details： function() {
			return  this.site + " - 学的不仅是技术，更是梦想！";
			}
	}	
})

指令：用在dom的元素中
(文本);		{{ }}
v-html;    	v-html="message"; message： '<h1>菜鸟教程</h1>';
v-bind;		v-bind：class="{'class1'： class1}"; v-bind：href="url";
{
缩写：
v-bind：href="url"; 
：href="url";
}
v-if;		v-if="seen";
v-for;		v-for="site in sites"
v-on;		v-on：click="doSomething";
{
缩写：
v-on：click="doSomething";  
@click="doSomething";
}
v-model;	v-model="message";

v-bind：样式绑定/属性绑定
v-bind：class="{ active： isActive, text-danger： hasError }"       	：设置一个对象，从而动态的切换 class
v-bind：class="[activeClass, errorClass]" 						 		：设置一个数组
v-bind：style="{ color： activeColor, fontSize： fontSize + 'px' }  	：可以直接设置样式
v-bind：style="[baseStyles, overridingStyles]"					 		：可以使用数组将多个样式对象应用到一个元素上：
v-bind：href="article.url"

判断：
v-if 			：判断条件是否成立(true/false/==)
v-else
v-else-if
v-show			：可以使用 v-show 指令来根据条件展示元素(v-if)

循环：
v-for
v-for="site in sites"					{{ site.name }}
v-for="value in object"					{{ value }}
v-for="(value, key) in object"			{{ key }} ： {{ value }}
v-for="(value, key, index) in object"	{{ index }}. {{ key }} ： {{ value }}
v-for="n in 10"							{{ n }}

v-on：事件处理（@）
v-on：click="counter += 1"
v-on：click="greet"

v-model				：表单上的数据绑定
input,textarea		：双向数据绑定
checkbox(复选框)	：如果是一个则为逻辑值，如果是多个则绑定到同一个数组,也是双向绑定
{
	checked ： true,
    checkedNames： []
}
radio(单选按钮)		：双向数据绑定
select(下拉列表)	：双向数据绑定
checkbox中的数组,radio,select中的{{ }}反映出来的值均为value的值。
剩下的几个{{  }}}反映出来的值为v-model的值。

属性：用在创建的vue实例中
el       ： el 参数，它是 DOM 元素中的 id(div)
data     ：{ }
methods  ：{ }
computed ： 计算属性{ }
watch    ：监听属性{ }

computed：计算属性
{
computed： {
    // 计算属性的 getter
    reversedMessage： function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
}
跟methods用法差不多，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。
而使用 methods ，在重新渲染的时候，函数总会重新调用执行。 
computed默认只有getter，不过也可以自己设置setter

watch：监听属性
通过watch属性来监听从而响应数据的变化。

























































































